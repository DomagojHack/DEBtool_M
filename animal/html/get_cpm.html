
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>get_cpm</title><meta name="generator" content="MATLAB 9.1"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-03-12"><meta name="DC.source" content="get_cpm.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>get_cpm</h1><!--introduction--><p>get cohort trajectories</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#3">Syntax</a></li><li><a href="#4">Description</a></li><li><a href="#5">Remarks</a></li></ul></div><h2 id="3">Syntax</h2><p>[tXN, tXW, M_N, M_W,, info] = <a href="../get_cpm.m"><b>get_cpm</b></a> (model, par, tT, tJX, x_0, n_R, t_R)</p><h2 id="4">Description</h2><p>integrates cohorts with synchronized reproduction events, called by cpm,</p><p>variables to be integrated, packed in Xvars:  X: mol/vol or mol/surface, food density    for each cohort:  q: 1/d^2, aging acceleration  h_a: 1/d, hazard for aging  L: cm, struc length  L_max: cm, struc length before start shrinking  E: J/cm^3, reserve density [E]  E_R: J, reprod buffer  E_H: J, maturity  N: #, number of individuals in cohort</p><p>number of current cohorts n_c = (length(Xvars) - 1)/8 n_c increases for 1 till some max value, determined by number of oldest cohort &lt; 1e-4, which depends on ageing and other hazards</p><p>Input:</p><div><ul><li>model: character-string with name of model</li><li>par: structure with parameter values</li><li>tT: (nT,2)-array with time and temperature in Kelvin; time scaled between 0 (= start) and 1 (= end of cycle)</li><li>tJX: (nX,2)-array with time and food supply; time scaled between 0 (= start) and 1 (= end of cycle)</li><li>x_0: scalar with scaled initial food density</li><li>V_X: scalar with volume of reactor</li><li>n_R: scalar with number of reproduction events to be simulated</li><li>t_R: scalar with time period between reproduction events</li></ul></div><p>Output:</p><div><ul><li>tXN: (n,m)-array with times, food density and number of individuals in the various cohorts</li><li>tXW: (n,m)-array with times, food density and total wet weights of the various cohorts</li><li>M_N: (n_c,n_c)-array with map for N: N(t+t_R) = M_N * N(t), where N(t) is the vector of numbers of individuals in the cohorts at t</li><li>M_W: (n_c,n_c)-array with map for W: W(t+t_R) = M_W * W(t), where W(t) is the vector of total wet weights in the cohorts at t</li><li>info: boolean with failure (0) or success (1)</li></ul></div><h2 id="5">Remarks</h2><p>The last 2 outputs (the maps for N and W) are only not-empty if the number of cohorts did not change long enough.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% get_cpm
% get cohort trajectories

%%
function [tXN, tXW, M_N, M_W, info] = get_cpm(model, par, tT, tJX, x_0, V_X, n_R, t_R)
% created 2020/03/03 by Bob Kooi & Bas Kooijman
  
%% Syntax
% [tXN, tXW, M_N, M_W,, info] = <../get_cpm.m *get_cpm*> (model, par, tT, tJX, x_0, n_R, t_R)
  
%% Description
% integrates cohorts with synchronized reproduction events, called by cpm, 
%
% variables to be integrated, packed in Xvars:
%  X: mol/vol or mol/surface, food density
%    for each cohort:
%  q: 1/d^2, aging acceleration
%  h_a: 1/d, hazard for aging
%  L: cm, struc length
%  L_max: cm, struc length before start shrinking
%  E: J/cm^3, reserve density [E]
%  E_R: J, reprod buffer
%  E_H: J, maturity
%  N: #, number of individuals in cohort
%
% number of current cohorts n_c = (length(Xvars) - 1)/8
% n_c increases for 1 till some max value, determined by number of oldest cohort < 1e-4, which depends on ageing and other hazards  
%
% Input:
%
% * model: character-string with name of model
% * par: structure with parameter values
% * tT: (nT,2)-array with time and temperature in Kelvin; time scaled between 0 (= start) and 1 (= end of cycle)
% * tJX: (nX,2)-array with time and food supply; time scaled between 0 (= start) and 1 (= end of cycle)
% * x_0: scalar with scaled initial food density 
% * V_X: scalar with volume of reactor
% * n_R: scalar with number of reproduction events to be simulated
% * t_R: scalar with time period between reproduction events 
%
% Output:
%
% * tXN: (n,m)-array with times, food density and number of individuals in the various cohorts
% * tXW: (n,m)-array with times, food density and total wet weights of the various cohorts
% * M_N: (n_c,n_c)-array with map for N: N(t+t_R) = M_N * N(t), where N(t) is the vector of numbers of individuals in the cohorts at t
% * M_W: (n_c,n_c)-array with map for W: W(t+t_R) = M_W * W(t), where W(t) is the vector of total wet weights in the cohorts at t
% * info: boolean with failure (0) or success (1)

%% Remarks
% The last 2 outputs (the maps for N and W) are only not-empty if the number of cohorts did not change long enough.

  options = odeset('Events',@puberty, 'AbsTol',1e-9, 'RelTol',1e-9);
  info = 1;
  
  % unpack par and compute compound pars
  vars_pull(par); vars_pull(parscomp_st(par));  
  
  % temperature correction
  par_T = T_A;
  if exist('T_L','var') && exist('T_AL','var')
    par_T = [T_A; T_L; T_AL];
  end
  if exist('T_L','var') && exist('T_AL','var') && exist('T_H','var') && exist('T_AH','var')
    par_T = [T_A; T_L; T_H; T_AL; T_AH]; 
  end
  % % unscale knots for temperature, and convert to temp correction factors
  if length(tT) == 1
     tTC = tempcorr(tT, T_ref, par_T);
  else
     tTC = [tT(:,1) * t_R, tempcorr(tT(:,2), T_ref, par_T)]; % uTemperature Correction factor
  end
  % unscale knots for food density in supply flux
  if length(tJX) > 1
    tJX(:,1) = tJX(:,1) * t_R; % unscale tJX
  end
  
  % initial reserve and states at birth appended to par
  switch model
    case {'stf','stx'}        
      [S_b, q_b, h_Ab, tau_b, tau_0b, u_E0, l_b] = get_Sb_foetus([g k v_Hb h_a s_G h_B0b 0]); 
    otherwise
      [S_b, q_b, h_Ab, tau_b, tau_0b, u_E0, l_b] = get_Sb([g k v_Hb h_a s_G h_B0b 0]);
  end
  E_0 = g * E_m * L_m^3 * u_E0;
  if length(tTC)==1
    aT_b = tau_b/ k_M/ tTC; 
  else
    aT_b = tau_b/ k_M/ spline1(0, tTC); 
  end
  L_b = l_b * L_m; 
  
  if t_R < aT_b
    fprintf('Warning from get_cpm: age at birth is larger than reproduction interval\n');
    info = 0; tXN = []; tXW = []; return
  end
  
  % initial states with number of cohorts n_c = 1;
  X_0 = x_0 * K; % unscale initial food density
  Xvars_0 = [X_0; 0; 0; L_b; L_b; E_m; 0; E_Hb; 1]; % X q h L L_max [E] E_R E_H N
  tXN = [0, X_0, 1]; tXW = [0, X_0, E_0/ mu_E * w_E/ d_E];% initialise output
  
  for i = 1:n_R
    switch model
      case 'std'
        par_std = {tTC, tJX, V_X, h_D, h_J, q_b, h_Ab, h_B0b, h_Bbp, h_Bpi, h_a, s_G, thin, S_b, aT_b, L_b, L_m, E_Hb, E_Hp, E_m, k_J, k_JX, v, g, p_M, p_Am, J_X_Am, K, kap, kap_G, del_X};
        [t, Xvars] = ode45(@dcpm_std, [0; aT_b; t_R], Xvars_0, options, par_std{:});
      case 'stf'
        [t, Xvars] = ode45(@dcpm_stf, [0; aT_b; t_R], Xvars_0, options, par, tTC, tX);
      case 'stx'
        [t, Xvars] = ode45(@dcpm_stx, [0; aT_b; t_R], Xvars_0, options, par, tTC, tX);
      case 'ssj'
        [t, Xvars] = ode45(@dcpm_ssj, [0; aT_b; t_R], Xvars_0, options, par, tTC, tX);
      case 'sbp'
        [t, Xvars] = ode45(@dcpm_sbp, [0; aT_b; t_R], Xvars_0, options, par, tTC, tX);
      case 'abj'
        [t, Xvars] = ode45(@dcpm_abj, [0; aT_b; t_R], Xvars_0, options, par, tTC, tX);
      case 'asj'
        [t, Xvars] = ode45(@dcpm_asj, [0; aT_b; t_R], Xvars_0, options, par, tTC, tX);
      case 'abp'
        [t, Xvars] = ode45(@dcpm_abp, [0; aT_b; t_R], Xvars_0, options, par, tTC, tX);
      case 'hep'
        [t, Xvars] = ode45(@dcpm_hep, [0; aT_b; t_R], Xvars_0, options, par, tTC, tX);
      case 'hex'
        [t, Xvars] = ode45(@dcpm_hex, [0; aT_b; t_R], Xvars_0, options, par, tTC, tX);
    end
    [t, Xvars_0, tXN, tXW] = cohorts(t(end), Xvars(end,:), tXN, tXW, t_R, E_0, kap_R, L_b, E_m, E_Hb, mu_E, w_E, d_E); % catenate output and possibly insert new cohort
    [i, (length(Xvars_0)-1)/8]
  end
  
  % maps
  M_N = []; M_W = []; n_c =(length(Xvars_0)-1)/8; % number of cohorts
  if length(tXN) > n_c && tXN(end - n_c - 1, end) > 0
    M_N = tXN(end-n_c:end,3:end)'/tXN(end-n_c-1:end-1,3:end)';
    M_W = tXW(end-n_c:end,3:end)'/tXW(end-n_c-1:end-1,3:end)';
  end
end


function [t, Xvars_0, tXN, tXW] = cohorts(t, Xvars, tXN, tXW, t_R, E_0, kap_R, L_b, E_m, E_Hb, mu_E, w_E, d_E)
  t = tXN(end,1) + t_R; Xvars_t = Xvars(end,:); % last value of t, Xvars
  [X, q, h_A, L, L_max, E, E_R, E_H, N] = cpm_unpack(Xvars_t);

  % reproduction event
  dN = kap_R * sum(N .* floor(E_R/ E_0)); % #, number of new eggs
  E_R = mod(E_R, E_0); % reduce reprod buffer to fractions of eggs
    
  % build new initial state vectors and append to output
  q = [0; q]; h_A = [0; h_A]; L = [L_b; L]; L_max = [L_b; L_max]; E = [E_m; E]; E_R = [0; E_R]; E_H = [E_Hb; E_H]; N = [dN; N]; 
  % most values for cogort 0 will be overwritten in dget_mod
  W = N .* L.^3 .* (1 + E/ mu_E * w_E/ d_E) + E_R/ mu_E * w_E/ d_E; % g, wet weights
  if N(end) > 1e-4 % add new youngest cohort
    tXN = [[tXN, zeros(size(tXN,1),1)]; [t, X, N']]; % append to output
    tXW = [[tXW, zeros(size(tXW,1),1)]; [t, X, W']]; % append to output
  else % add new youngest cohort and remove oldest
    q(end)=[]; h_A(end)=[]; L(end)=[]; L_max(end)=[]; E(end)=[]; E_R(end)=[]; E_H(end)=[]; N(end)=[]; W(end)=[];
    tXN = [tXN; [t, X, N']]; % append to output
    tXW = [tXW; [t, X, W']]; % append to output
  end
  Xvars_0 = max(0,[X; q; h_A; L; L_max; E; E_R; E_H; N]); % pack state vars
end

function [value,isterminal,direction] = puberty(t, Xvars, tTC, tJX, V_X, h_D, h_J, q_b, h_Ab, h_B0b, h_Bbp, h_Bpi, h_a, s_G, thin, S_b, aT_b, L_b, L_m, E_Hb, E_Hp, E_m, k_M, k_J, k_JX, v, g, p_M, p_Am, J_X_Am, K, kap, kap_G, del_X)
  n_c = (length(Xvars) - 1)/ 8; % #, number of cohorts
  E_H = Xvars(1+4*n_c+(1:n_c)); % J, maturities, cf cpm_unpack
  value = min(abs(E_H - E_Hp)); % trigger 
  isterminal = 0;  % continue after event
  direction  = []; % get all the zeros
end


##### SOURCE END #####
--></body></html>